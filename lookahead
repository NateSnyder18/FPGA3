module lookahead(input [1:0] A, B, output [6:0] seg);


    wire [2:0] wc;
    wire [1:0] wg, wp, s;
    wire [3:0] bcd;
   
   
    assign wg[0] = A[0] & B[0];
    assign wg[1] = A[1] & B[1];
   
    assign wp[0] = A[0] ^ B[0];
    assign wp[1] = A[1] ^ B[1];
   
    assign wc[0] = 1'b0;
    assign wc[1] = wg[0]|(wp[0] & wc[0]);
    assign wc[2] = wg[1]|(wp[1] & wc[1]);
   
    one_adder uut1(.A(A[0]), .B(B[0]), .CI(wc[0]), .SUM( s[0]));
    one_adder uut2(.A(A[1]), .B(B[1]), .CI(wc[1]), .SUM( s[1]));
   
    assign bcd = {1'b0,wc[2],s}; //4bits
   
    segConv S1(bcd, seg);
   
endmodule


module one_adder(A, B, CI, CO, SUM);
    input A, B, CI;
    output CO, SUM;
    assign SUM = (A^B^CI);
    assign CO = (A&B&CI)|(A&B&~CI)|(A&~B&CI)|(~A&B&CI);
endmodule

module segConv(bcd, seg);
    input [3:0] bcd;
    output [6:0] seg;
    reg [6:0] seg;
   
    always @ (bcd)
    begin
        case (bcd)
            0: seg=7'b0000001;
            1: seg=7'b1001111;
            2: seg=7'b0010010;
            3: seg=7'b0000110;
            4: seg=7'b1001100;
            5: seg=7'b0100100;
            6: seg=7'b0100000;
            7: seg=7'b0001111;
            8: seg=7'b0000000;
            9: seg=7'b0000100;
            default: seg=7'b1111111;
         endcase
     end
   
endmodule
